# modules/xml_generator.py
"""
Модуль генерации RDF/XML с поддержкой внешних uid и подробным логированием.
"""

from typing import List, Tuple, Dict
from uuid import uuid5, NAMESPACE_X500
import logging
from .config_manager import get_config_manager


class XMLGenerator:
    """
    Генератор RDF/XML с поддержкой внешних uid.
    Внешние uid добавляются ТОЛЬКО как ссылки в ChildObjects родителя.
    """

    def __init__(self):
        self.config = get_config_manager().config
        xml_config = self.config["xml_generation"]
        self.logger = logging.getLogger("xml_generator")

        # Все пространства имён
        self.namespaces = xml_config["namespaces"]  # dict
        self.logger.debug(
            f"Загружены пространства имён: {list(self.namespaces.keys())}")

        # Метаданные модели
        self.model_id = f"#_{xml_config['model_id']}"
        self.model_created = xml_config["model_created"]
        self.model_version = xml_config["model_version"]
        self.model_name = xml_config["model_name"]

        self.logger.info("Инициализация XMLGenerator завершена")

    def _generate_id(self, path: Tuple[str, ...]) -> str:
        """Генерирует стабильный UUID на основе пути."""
        path_str = " -> ".join(path)
        return f"#_{uuid5(NAMESPACE_X500, path_str).hex}"

    # modules/xml_generator.py

    def generate(self, paths: List[Tuple[str, ...]], external_children: Dict[Tuple[str, ...], List[str]], parent_uid: str) -> str:
        """
        Генерирует RDF/XML с поддержкой внешних uid.
        Объекты с uid НЕ создаются, только добавляются как ссылки.
        """
        from collections import defaultdict
        from queue import Queue
        import logging

        self.logger = logging.getLogger("xml_generator")
        self.logger.info("Начало генерации RDF/XML")
        self.logger.debug(
            f"Входные данные: {len(paths)} путей, {sum(len(v) for v in external_children.values())} внешних uid")

        if not paths:
            self.logger.error("Нет данных для генерации")
            raise ValueError("Пустая иерархия")

        # === 1. Построение дерева (только для объектов БЕЗ uid) ===
        all_nodes = set()
        children_map = defaultdict(list)
        parent_map = {}

        for path in paths:
            for i in range(1, len(path)):
                parent = tuple(path[:i])
                child = tuple(path[:i+1])
                if child not in children_map[parent]:
                    children_map[parent].append(child)
                parent_map[child] = parent
            for i in range(1, len(path) + 1):
                all_nodes.add(tuple(path[:i]))

        leaf_nodes = {node for node in all_nodes if not children_map.get(node)}
        id_map = {node: self._generate_id(node) for node in all_nodes}

        self.logger.debug(
            f"Построено дерево: {len(all_nodes)} узлов, {len(leaf_nodes)} листьев")

        # === 2. Формирование XML ===
        lines = []

        # Шапка
        lines.append('<?xml version="1.0" encoding="utf-8"?>')
        lines.append('<?iec61970-552 version="2.0"?>')
        lines.append('<?floatExporter 1?>')

        rdf_open = '<rdf:RDF'
        for prefix, uri in self.namespaces.items():
            rdf_open += f' xmlns:{prefix}="{uri}"'
        rdf_open += '>'
        lines.append(rdf_open)

        # FullModel
        full_model_id = f"#_{self.config['xml_generation']['model_id']}"
        lines.append(f'  <md:FullModel rdf:about="{full_model_id}">')
        lines.append(
            f'    <md:Model.created>{self.model_created}</md:Model.created>')
        lines.append(
            f'    <md:Model.version>{self.model_version}</md:Model.version>')
        lines.append(f'    <me:Model.name>{self.model_name}</me:Model.name>')
        lines.append('  </md:FullModel>')

        lines.append('  <!-- Generated by XMLGenerator -->')
        lines.append('  <!-- IEC 61970 CIM RDF/XML Model -->')

        # === 3. Генерация объектов ===
        processed = set()
        q = Queue()

        # Начинаем с корневых путей
        root_paths = [path for path in paths if len(path) == 1]
        for root in root_paths:
            q.put(root)

        nodes_added = 0
        while not q.empty():
            current = q.get()
            if current in processed:
                continue
            processed.add(current)
            nodes_added += 1

            current_id = id_map[current]

            # Объект является листом, если у него нет ни обычных, ни внешних детей
            is_leaf = (current not in children_map or not children_map[current]) and (
                current not in external_children or not external_children[current])

            if len(current) == 1:
                # Корневой объект
                lines.append(
                    f'  <cim:AssetContainer rdf:about="{current_id}">')
                lines.append(
                    f'    <cim:IdentifiedObject.name>{current[-1]}</cim:IdentifiedObject.name>')
                lines.append(
                    f'    <me:IdentifiedObject.ParentObject rdf:resource="{parent_uid}" />')
            elif is_leaf:
                # Листовой объект (без детей вообще)
                lines.append(f'  <me:GenericPSR rdf:about="{current_id}">')
                lines.append(
                    f'    <cim:IdentifiedObject.name>{current[-1]}</cim:IdentifiedObject.name>')
                parent_id = id_map[parent_map[current]]
                lines.append(
                    f'    <me:IdentifiedObject.ParentObject rdf:resource="{parent_id}" />')
                lines.append(
                    f'    <cim:PowerSystemResource.Assets rdf:resource="{parent_id}" />')
                lines.append('  </me:GenericPSR>')
                continue
            else:
                # Промежуточный контейнер
                lines.append(
                    f'  <cim:AssetContainer rdf:about="{current_id}">')
                lines.append(
                    f'    <cim:IdentifiedObject.name>{current[-1]}</cim:IdentifiedObject.name>')
                parent_id = id_map[parent_map[current]]
                lines.append(
                    f'    <me:IdentifiedObject.ParentObject rdf:resource="{parent_id}" />')

            # Добавляем дочерние ссылки
            added_children = set()

            # Обычные дети
            if current in children_map:
                for child in children_map[current]:
                    child_id = id_map[child]
                    if child_id not in added_children:
                        lines.append(
                            f'    <me:IdentifiedObject.ChildObjects rdf:resource="{child_id}" />')
                        lines.append(
                            f'    <cim:AssetContainer.Assets rdf:resource="{child_id}" />')
                        added_children.add(child_id)
                        q.put(child)

            # Внешние дети (только ссылки)
            if current in external_children:
                for uid in external_children[current]:
                    ext_id = f"#_{uid}"
                    if ext_id not in added_children:
                        lines.append(
                            f'    <me:IdentifiedObject.ChildObjects rdf:resource="{ext_id}" />')
                        added_children.add(ext_id)

            lines.append('  </cim:AssetContainer>')

        lines.append('</rdf:RDF>')
        self.logger.info(
            f"Генерация XML завершена. Всего добавлено узлов: {nodes_added}")
        return '\n'.join(lines)
